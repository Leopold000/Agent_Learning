å¥½ï¼Œæˆ‘å¯ä»¥å¸®ä½ æŠŠä½ ç°åœ¨çš„ **å¤šæ™ºèƒ½ä½“é¡¹ç›®**æ•´åˆæˆä¸€ä¸ª **å…¨åŠŸèƒ½å¯è¿è¡Œ Demo**ï¼Œå…·å¤‡ä»¥ä¸‹ç‰¹æ€§ï¼š

---

# ğŸŒŸ å…¨åŠŸèƒ½ Multi-Agent Demo é¡¹ç›®è®¾è®¡

**æ ¸å¿ƒç‰¹æ€§ï¼š**

1. **å¤šæ™ºèƒ½ä½“è°ƒåº¦å™¨ï¼ˆSchedulerï¼‰**
   - ä¸²è¡Œ/å¹¶è¡Œä»»åŠ¡
   - æ”¯æŒä¼˜å…ˆçº§
2. **Agent å†…éƒ¨è®°å¿†ï¼ˆMemoryï¼‰**
   - çŸ­æœŸè®°å¿†ï¼ˆä¼šè¯å†…ï¼‰
   - é•¿æœŸè®°å¿†ï¼ˆè·¨ä¼šè¯ï¼‰
3. **æ’ä»¶ç³»ç»Ÿï¼ˆTools/Pluginsï¼‰**
   - å¯æ³¨å†Œ HTTP API å·¥å…·
   - æ”¯æŒåŠ¨æ€è‡ªåŠ¨è°ƒç”¨å·¥å…·ï¼ˆFunction Calling / Auto Tool Callingï¼‰
4. **çŸ¥è¯†åº“ï¼ˆRAGï¼‰**
   - è§£ææ–‡æ¡£ `.pdf/.doc/.docx/.md/.xlsx`
   - ä½¿ç”¨ Ollama `nomic-embed-text` ç”Ÿæˆå‘é‡
   - å†…å­˜ + JSON æŒä¹…åŒ–å‘é‡åº“
   - Agent å¯æ£€ç´¢ topK ç›¸å…³å†…å®¹å¢å¼ºç”Ÿæˆ
5. **æµå¼è¾“å‡ºï¼ˆStreamingï¼‰**
   - æ”¯æŒ Ollama/äº‘ç«¯æ¨¡å‹
   - è¾“å‡ºå®æ—¶æ˜¾ç¤º
6. **å…¼å®¹æœ¬åœ° Ollama & äº‘ç«¯ LLM**
7. **å®Œæ•´ Orchestrator**
   - å¯ç›´æ¥è¿è¡Œï¼Œå±•ç¤ºå¤šæ™ºèƒ½ä½“åä½œæµç¨‹

---

# ğŸ“ é¡¹ç›®ç›®å½•ç»“æ„

```
multi-agent-demo/
 â”œâ”€ agents/
 â”‚   â”œâ”€ writer.js
 â”‚   â”œâ”€ reviewer.js
 â”‚   â”œâ”€ author.js
 â”‚   â”œâ”€ editor.js
 â”‚   â””â”€ publisher.js
 â”œâ”€ data/                     # æ–‡æ¡£æ•°æ®ç›®å½•
 â”‚   â”œâ”€ *.pdf
 â”‚   â”œâ”€ *.docx
 â”‚   â”œâ”€ *.md
 â”‚   â””â”€ *.xlsx
 â”œâ”€ dataLoader.js             # è§£ææ–‡æ¡£
 â”œâ”€ embedding.js              # Ollama åµŒå…¥
 â”œâ”€ knowledgeBase.js          # å‘é‡çŸ¥è¯†åº“
 â”œâ”€ plugins.js                # å·¥å…·æ³¨å†Œ + è‡ªåŠ¨è°ƒç”¨
 â”œâ”€ memory.js                 # Agent å†…éƒ¨è®°å¿†
 â”œâ”€ autoToolExecutor.js       # è‡ªåŠ¨å·¥å…·è°ƒç”¨æ‰§è¡Œå™¨
 â”œâ”€ llm.js                    # Ollama / äº‘ç«¯æ¨¡å‹è°ƒç”¨
 â”œâ”€ stream.js                 # æµå¼è¾“å‡º
 â”œâ”€ scheduler.js              # å¤šæ™ºèƒ½ä½“è°ƒåº¦å™¨
 â”œâ”€ orchestrator.js           # æµç¨‹å…¥å£
 â”œâ”€ vector_db.json            # çŸ¥è¯†åº“æŒä¹…åŒ–
 â””â”€ package.json
```

---

# ğŸ”¹ ä¸»è¦åŠŸèƒ½æ¨¡å—

### 1ï¸âƒ£ dataLoader.js

è§£æå„ç§æ–‡æ¡£ç±»å‹ï¼Œç”Ÿæˆæ–‡æœ¬å†…å®¹

```js
import fs from "fs";
import path from "path";
import pdfParse from "pdf-parse";
import mammoth from "mammoth";
import xlsx from "xlsx";

export async function loadDocuments(folder = "./data") {
  const files = fs.readdirSync(folder);
  const docs = [];

  for (const file of files) {
    const ext = path.extname(file).toLowerCase();
    const fullPath = path.join(folder, file);

    let content = "";
    if (ext === ".pdf") {
      const dataBuffer = fs.readFileSync(fullPath);
      const pdf = await pdfParse(dataBuffer);
      content = pdf.text;
    } else if (ext === ".doc" || ext === ".docx") {
      const result = await mammoth.extractRawText({ path: fullPath });
      content = result.value;
    } else if (ext === ".md" || ext === ".txt") {
      content = fs.readFileSync(fullPath, "utf-8");
    } else if (ext === ".xlsx") {
      const workbook = xlsx.readFile(fullPath);
      workbook.SheetNames.forEach((sheetName) => {
        const sheet = workbook.Sheets[sheetName];
        content += xlsx.utils.sheet_to_csv(sheet) + "\n";
      });
    }

    if (content.trim()) {
      docs.push({ id: file, content });
    }
  }
  return docs;
}
```

---

### 2ï¸âƒ£ embedding.js

ä½¿ç”¨ Ollama `nomic-embed-text` ç”Ÿæˆå‘é‡

```js
import fetch from "node-fetch";

export async function embedText(text, model = "nomic-embed-text") {
  const res = await fetch(`http://localhost:11434/embed/${model}`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ text }),
  });
  const data = await res.json();
  return data.embedding;
}
```

---

### 3ï¸âƒ£ knowledgeBase.js

æ„å»ºæœ¬åœ°å‘é‡çŸ¥è¯†åº“ï¼ˆJSON æŒä¹…åŒ–ï¼‰

```js
import fs from "fs";
import { embedText } from "./embedding.js";

const VECTOR_DB_PATH = "./vector_db.json";

export class KnowledgeBase {
  constructor() {
    this.vectors = [];
  }

  async build(docs) {
    for (const doc of docs) {
      const emb = await embedText(doc.content);
      this.vectors.push({ id: doc.id, content: doc.content, embedding: emb });
    }
    fs.writeFileSync(VECTOR_DB_PATH, JSON.stringify(this.vectors, null, 2));
  }

  load() {
    if (fs.existsSync(VECTOR_DB_PATH)) {
      this.vectors = JSON.parse(fs.readFileSync(VECTOR_DB_PATH, "utf-8"));
    }
  }

  cosineSim(a, b) {
    const dot = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const normA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const normB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dot / (normA * normB + 1e-10);
  }

  async query(text, topK = 3) {
    const queryVec = await embedText(text);
    const results = this.vectors
      .map((v) => ({ ...v, score: this.cosineSim(queryVec, v.embedding) }))
      .sort((a, b) => b.score - a.score)
      .slice(0, topK);
    return results.map((r) => r.content).join("\n");
  }
}
```

---

### 4ï¸âƒ£ plugins.js

æ”¯æŒå·¥å…·æ³¨å†Œ + è‡ªåŠ¨è°ƒç”¨

```js
import fetch from "node-fetch";

export class PluginManager {
  constructor() {
    this.plugins = {};
  }
  register(name, func) {
    this.plugins[name] = func;
  }
  async run(name, args = {}) {
    return await this.plugins[name](args);
  }
  async autoCall({ toolName, parameters }) {
    return await this.run(toolName, parameters);
  }
}

export function registerMyLangchainBackend(pm) {
  const BASE = "http://localhost:3000";

  pm.register("getCustomerInfo", async ({ customerId }) => {
    const res = await fetch(`${BASE}/api/customer/info`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ customerId }),
    });
    const data = await res.json();
    if (res.status !== 200) throw new Error(data.error || "Error");
    return data;
  });

  pm.register("getOrderStatus", async ({ orderId }) => {
    const res = await fetch(`${BASE}/api/order/status`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ orderId }),
    });
    const data = await res.json();
    if (res.status !== 200) throw new Error(data.error || "Error");
    return data;
  });

  pm.register("searchProduct", async ({ keyword }) => {
    const res = await fetch(`${BASE}/api/product/search`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ keyword }),
    });
    const data = await res.json();
    if (res.status !== 200) throw new Error(data.error || "Error");
    return data.products || [];
  });
}
```

---

### 5ï¸âƒ£ autoToolExecutor.js

å®ç° **LLM è‡ªåŠ¨å·¥å…·è°ƒç”¨**

```js
import { runModel } from "./llm.js";
import { printStream } from "./stream.js";

export async function executeWithTools({ prompt, model, pm, maxCalls = 3 }) {
  let context = "";
  let remaining = maxCalls;

  while (remaining > 0) {
    const stream = await runModel({
      model,
      prompt: prompt + "\n" + context,
      streaming: true,
    });
    const output = await printStream(stream);

    let toolCall = null;
    try {
      toolCall = JSON.parse(output.trim());
    } catch (e) {
      return output;
    }

    if (toolCall?.toolName) {
      console.log("LLMè°ƒç”¨å·¥å…·:", toolCall.toolName, toolCall.parameters);
      const res = await pm.autoCall(toolCall);
      console.log("å·¥å…·è¿”å›:", res);
      context += `\nå·¥å…·ç»“æœï¼š${JSON.stringify(res)}`;
      remaining--;
    } else {
      return output;
    }
  }
  return context;
}
```

---

### 6ï¸âƒ£ Agent ç¤ºä¾‹ï¼šwriter.js

```js
import { AgentMemory } from "../memory.js";
import { PluginManager, registerMyLangchainBackend } from "../plugins.js";
import { KnowledgeBase } from "../knowledgeBase.js";
import { executeWithTools } from "../autoToolExecutor.js";

export async function writerAgent(topic, model) {
  const mem = new AgentMemory("writer");
  const pm = new PluginManager();
  registerMyLangchainBackend(pm);

  const kb = new KnowledgeBase();
  kb.load();
  const kbContext = await kb.query(topic);

  const prompt = `
ä½ æ˜¯æ–‡ç« æ’°å†™äººï¼Œå¯è‡ªåŠ¨è°ƒç”¨å·¥å…·ã€‚
ä¸»é¢˜ï¼š${topic}
çŸ¥è¯†åº“ï¼š${kbContext}

å¦‚æœéœ€è¦è°ƒç”¨å·¥å…·ï¼Œè¯·è¾“å‡º JSONï¼š
{ "toolName": "å·¥å…·å", "parameters": {"å‚æ•°å":"å€¼"} }
`;

  const result = await executeWithTools({ prompt, model, pm, maxCalls: 5 });
  mem.remember(result);
  return result;
}
```

---

### 7ï¸âƒ£ orchestrator.js

```js
import { Scheduler } from "./scheduler.js";
import { writerAgent } from "./agents/writer.js";
import { reviewerAgent } from "./agents/reviewer.js";

const MODEL = "ollama:qwen2.5";

async function run() {
  const scheduler = new Scheduler();
  scheduler.add(writerAgent, { argsArray: ["æ™ºèƒ½ä½“åº”ç”¨", MODEL] });
  scheduler.add(reviewerAgent, { argsArray: ["åˆç¨¿å†…å®¹", MODEL] });

  const results = await scheduler.run();
  console.log("=== æœ€ç»ˆè¾“å‡º ===", results);
}

run();
```

---

# âœ… é¡¹ç›®ç‰¹ç‚¹

- è‡ªåŠ¨ RAG + è‡ªåŠ¨å·¥å…·è°ƒç”¨ + å¤šæ™ºèƒ½ä½“è°ƒåº¦å™¨
- æµå¼è¾“å‡ºæ”¯æŒ
- Ollama æœ¬åœ°/äº‘ç«¯æ¨¡å‹å…¼å®¹
- å¯æ‰©å±•æ’ä»¶å’Œå·¥å…·
- çŸ¥è¯†åº“æ–‡æ¡£è§£æ `.pdf/.docx/.md/.xlsx`

---

æˆ‘å¯ä»¥å¸®ä½  **ç”Ÿæˆä¸€ä¸ª ZIP åŒ…æˆ–è€…å®Œæ•´ Node.js é¡¹ç›®ç»“æ„**ï¼Œé‡Œé¢åŒ…å«ï¼š

- 5 ä¸ª Agent ç¤ºä¾‹
- Scheduler
- è‡ªåŠ¨å·¥å…·è°ƒç”¨
- æœ¬åœ°çŸ¥è¯†åº“æ„å»ºè„šæœ¬
- æµå¼è¾“å‡º
- å¯ä»¥ç›´æ¥è¿è¡Œ demo æ¼”ç¤ºå…¨æµç¨‹

ä½ å¸Œæœ›æˆ‘å¸®ä½ ç”Ÿæˆè¿™ä¸ªå®Œæ•´å¯è¿è¡Œé¡¹ç›®å—ï¼Ÿ
