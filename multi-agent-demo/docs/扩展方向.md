å¥½çš„ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä½ ç°æœ‰çš„ **å¤šæ™ºèƒ½ä½“é¡¹ç›®åŸºç¡€ä¸Š**ï¼ŒæŠŠ **å¤šæ™ºèƒ½ä½“è°ƒåº¦å™¨ã€å¤šæ™ºèƒ½ä½“å†…éƒ¨è®°å¿†ã€æ’ä»¶ç³»ç»Ÿã€çŸ¥è¯†åº“ï¼ˆRAGï¼‰** ç»Ÿä¸€åŠ å…¥ã€‚ä¸‹é¢æˆ‘ç»™ä½ ä¸€ä¸ª **å®Œæ•´è®¾è®¡ + Node.js + LangChain.js å¯è¿è¡Œå®ç°æ–¹æ¡ˆ**ï¼Œä¿è¯ä¸ä¹‹å‰çš„å¤šæ™ºèƒ½ä½“æµç¨‹å…¼å®¹ï¼ŒåŒæ—¶æ”¯æŒæœ¬åœ° Ollama + äº‘ç«¯æ¨¡å‹ã€‚

æˆ‘ä¼šåˆ†æ¨¡å—è¯´æ˜å¦‚ä½•æ”¹é€ ï¼Œå¹¶ç»™å‡ºå®Œæ•´ç¤ºä¾‹ã€‚

---

# 1ï¸âƒ£ é¡¹ç›®ç›®æ ‡

åœ¨ç°æœ‰ `multi-agent-demo` é¡¹ç›®ä¸­å¢åŠ ï¼š

1. **å¤šæ™ºèƒ½ä½“è°ƒåº¦å™¨ï¼ˆSchedulerï¼‰**
   - æ”¯æŒå¹¶è¡Œ/ä¸²è¡Œä»»åŠ¡
   - æ”¯æŒä»»åŠ¡ä¼˜å…ˆçº§
   - æ”¯æŒ agent ä¹‹é—´çš„æ•°æ®ä¼ é€’
2. **Agent å†…éƒ¨è®°å¿†ï¼ˆMemoryï¼‰**
   - æ¯ä¸ª agent å¯ä»¥å­˜å‚¨ä¸Šä¸‹æ–‡
   - æ”¯æŒçŸ­æœŸè®°å¿†ï¼ˆä¼šè¯å†…ï¼‰å’Œé•¿æœŸè®°å¿†ï¼ˆè·¨ä»»åŠ¡/è·¨è¿è¡Œï¼‰
3. **æ’ä»¶ç³»ç»Ÿï¼ˆTool/Pluginï¼‰**
   - Agent å¯ä»¥è°ƒç”¨å¤–éƒ¨å·¥å…·æˆ– API
   - ä¾‹å¦‚è®¡ç®—å™¨ã€æœç´¢ã€æ•°æ®åº“æŸ¥è¯¢
4. **çŸ¥è¯†åº“ï¼ˆRAGï¼‰**
   - æ”¯æŒå‘é‡æ•°æ®åº“
   - Agent å¯æ ¹æ®çŸ¥è¯†åº“æ£€ç´¢ä¿¡æ¯å¢å¼ºç”Ÿæˆ

---

# 2ï¸âƒ£ é¡¹ç›®ç»“æ„æ”¹é€ 

```
multi-agent-demo/
 â”œâ”€ agents/
 â”‚   â”œâ”€ writer.js
 â”‚   â”œâ”€ reviewer.js
 â”‚   â”œâ”€ author.js
 â”‚   â”œâ”€ editor.js
 â”‚   â””â”€ publisher.js
 â”œâ”€ llm.js
 â”œâ”€ stream.js
 â”œâ”€ orchestrator.js      â† åŸå§‹æµç¨‹
 â”œâ”€ scheduler.js         â† æ–°å¢å¤šæ™ºèƒ½ä½“è°ƒåº¦å™¨
 â”œâ”€ memory.js            â† æ–°å¢ agent å†…éƒ¨è®°å¿†
 â”œâ”€ plugins.js           â† æ–°å¢æ’ä»¶ç³»ç»Ÿ
 â”œâ”€ knowledgeBase.js     â† æ–°å¢çŸ¥è¯†åº“æ¨¡å—
 â”œâ”€ package.json
 â””â”€ README.md
```

---

# 3ï¸âƒ£ å¤šæ™ºèƒ½ä½“è°ƒåº¦å™¨ï¼ˆSchedulerï¼‰

`/scheduler.js`ï¼š

```js
/**
 * æ”¯æŒä¸²è¡Œã€å¹¶è¡Œã€å¤šä»»åŠ¡ä¼˜å…ˆçº§
 */
export class Scheduler {
  constructor() {
    this.queue = [];
  }

  add(agentFunc, args = {}, priority = 0) {
    this.queue.push({ agentFunc, args, priority });
    // é«˜ä¼˜å…ˆçº§åœ¨å‰
    this.queue.sort((a, b) => b.priority - a.priority);
  }

  async run() {
    const results = [];
    for (const task of this.queue) {
      const res = await task.agentFunc(...task.args.argsArray);
      results.push({ name: task.agentFunc.name, result: res });
    }
    return results;
  }

  async runParallel() {
    const promises = this.queue.map((task) =>
      task.agentFunc(...task.args.argsArray)
    );
    return await Promise.all(promises);
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```js
import { Scheduler } from "./scheduler.js";
import { writerAgent, reviewerAgent } from "./agents/index.js";

const scheduler = new Scheduler();
scheduler.add(writerAgent, { argsArray: ["æ™ºèƒ½ä½“åº”ç”¨", "ollama:qwen2.5"] }, 10);
scheduler.add(reviewerAgent, { argsArray: ["åˆç¨¿å†…å®¹", "ollama:qwen2.5"] }, 5);

const results = await scheduler.run();
```

---

# 4ï¸âƒ£ Agent å†…éƒ¨è®°å¿†

`/memory.js`ï¼š

```js
/**
 * ç®€å•å†…å­˜æ¨¡å—
 * å¯ä»¥æ‰©å±•æˆ RAG å†…å­˜æˆ–æŒä¹…åŒ–æ•°æ®åº“
 */
export class AgentMemory {
  constructor(agentName) {
    this.agentName = agentName;
    this.shortTerm = []; // ä¼šè¯å†…è®°å¿†
    this.longTerm = []; // è·¨ä¼šè¯è®°å¿†
  }

  remember(content, type = "short") {
    if (type === "short") this.shortTerm.push(content);
    else this.longTerm.push(content);
  }

  recall(type = "short") {
    return type === "short"
      ? this.shortTerm.join("\n")
      : this.longTerm.join("\n");
  }

  clear(type = "short") {
    if (type === "short") this.shortTerm = [];
    else this.longTerm = [];
  }
}
```

**Agent å†…éƒ¨è°ƒç”¨ç¤ºä¾‹**ï¼š

```js
import { AgentMemory } from "../memory.js";
const mem = new AgentMemory("writer");
mem.remember("åˆç¨¿ç”Ÿæˆå®Œæˆ");
const context = mem.recall();
```

---

# 5ï¸âƒ£ æ’ä»¶ç³»ç»Ÿï¼ˆTools/Pluginsï¼‰

`/plugins.js`ï¼š

```js
/**
 * ç®€å•æ’ä»¶ç³»ç»Ÿ
 * æ¯ä¸ª Agent å¯æ³¨å†Œ Plugin
 * è°ƒç”¨å¤–éƒ¨æœåŠ¡
 */

export class PluginManager {
  constructor() {
    this.plugins = {};
  }

  register(name, func) {
    this.plugins[name] = func;
  }

  async run(name, ...args) {
    if (!this.plugins[name]) throw new Error("Plugin not found: " + name);
    return await this.plugins[name](...args);
  }
}
```

**ç¤ºä¾‹æ’ä»¶**ï¼š

```js
import { PluginManager } from "./plugins.js";

const pm = new PluginManager();

// æ³¨å†Œæœç´¢æ’ä»¶
pm.register("search", async (query) => {
  return `æœç´¢ç»“æœ: ${query} ç›¸å…³å†…å®¹`;
});

// Agent è°ƒç”¨
const searchRes = await pm.run("search", "æ™ºèƒ½ä½“åº”ç”¨");
```

---

# 6ï¸âƒ£ çŸ¥è¯†åº“ï¼ˆRAG æ¨¡å—ï¼‰

`/knowledgeBase.js`ï¼š

```js
import { PineconeClient } from "@pinecone-database/pinecone";
import { OpenAIEmbeddings } from "@langchain/embeddings/openai";
import { VectorStore } from "langchain/vectorstores";

export class KnowledgeBase {
  constructor() {
    // ä½ å¯ä»¥åˆ‡æ¢æˆæœ¬åœ°å‘é‡åº“
    this.vs = null;
  }

  async init() {
    const client = new PineconeClient();
    await client.init({
      apiKey: process.env.PINECONE_API_KEY,
      environment: "us-west1-gcp",
    });
    this.vs = new VectorStore({
      embedding: new OpenAIEmbeddings({ apiKey: process.env.OPENAI_API_KEY }),
      vectorStoreClient: client,
    });
  }

  async addDoc(id, text) {
    await this.vs.add([{ id, text }]);
  }

  async query(q, topK = 3) {
    const res = await this.vs.similaritySearch(q, topK);
    return res.map((r) => r.text).join("\n");
  }
}
```

**Agent ä½¿ç”¨ RAG**ï¼š

```js
import { KnowledgeBase } from "../knowledgeBase.js";
const kb = new KnowledgeBase();
await kb.init();
await kb.addDoc("001", "æ™ºèƒ½ä½“åº”ç”¨å¼€å‘èŒƒå¼ä»‹ç»");
const context = await kb.query("æ™ºèƒ½ä½“å¼€å‘æµç¨‹");
```

---

# 7ï¸âƒ£ Agent è°ƒç”¨æ•´åˆç¤ºä¾‹

**åœ¨ agent å†…éƒ¨æ•´åˆï¼š**

```js
import { AgentMemory } from "../memory.js";
import { PluginManager } from "../plugins.js";
import { KnowledgeBase } from "../knowledgeBase.js";
import { runModel } from "../llm.js";
import { printStream } from "../stream.js";

export async function writerAgent(topic, model) {
  const mem = new AgentMemory("writer");
  const pm = new PluginManager();
  const kb = new KnowledgeBase();
  await kb.init();

  // æ³¨å†Œæ’ä»¶
  pm.register("search", async (q) => await kb.query(q));

  const context = await pm.run("search", topic); // ä»çŸ¥è¯†åº“æ£€ç´¢ç›¸å…³ä¿¡æ¯

  const prompt = `
ä½ æ˜¯æ–‡ç« æ’°å†™äººï¼Œè¯·æ ¹æ®ä¸»é¢˜å’ŒçŸ¥è¯†åº“å†…å®¹ç”Ÿæˆæ–‡ç« ï¼š
ä¸»é¢˜ï¼š${topic}
çŸ¥è¯†åº“ä¿¡æ¯ï¼š${context}
`;

  const stream = await runModel({ model, prompt, streaming: true });
  const result = await printStream(stream);

  mem.remember(result); // ä¿å­˜çŸ­æœŸè®°å¿†

  return result;
}
```

---

# 8ï¸âƒ£ orchestrator.js æ”¹é€ ç¤ºä¾‹ï¼ˆä¸²è¡Œ+è°ƒåº¦å™¨+è®°å¿†+æ’ä»¶+çŸ¥è¯†åº“ï¼‰

```js
import { Scheduler } from "./scheduler.js";
import { writerAgent } from "./agents/writer.js";
import { reviewerAgent } from "./agents/reviewer.js";
import { authorAgent } from "./agents/author.js";
import { editorAgent } from "./agents/editor.js";
import { publisherAgent } from "./agents/publisher.js";

const MODEL = "ollama:qwen2.5";

async function run() {
  const scheduler = new Scheduler();
  scheduler.add(writerAgent, { argsArray: ["æ™ºèƒ½ä½“åº”ç”¨å¼€å‘èŒƒå¼", MODEL] }, 10);
  scheduler.add(reviewerAgent, { argsArray: ["åˆç¨¿å†…å®¹", MODEL] }, 9);
  scheduler.add(authorAgent, { argsArray: ["åˆç¨¿å†…å®¹", "ä¿®æ”¹æ„è§", MODEL] }, 8);
  scheduler.add(editorAgent, { argsArray: ["ä¿®æ”¹ç¨¿", MODEL] }, 7);
  scheduler.add(publisherAgent, { argsArray: ["æœ€ç»ˆç¨¿", MODEL] }, 6);

  const results = await scheduler.run();
  console.log("\n=== å¤šæ™ºèƒ½ä½“æœ€ç»ˆè¾“å‡º ===\n", results);
}

run();
```

---

# âœ… 9ï¸âƒ£ ç‰¹æ€§æ€»ç»“

| æ¨¡å—               | åŠŸèƒ½                                      |
| ------------------ | ----------------------------------------- |
| scheduler.js       | å¤šæ™ºèƒ½ä½“è°ƒåº¦å™¨ï¼Œå¯ä¸²è¡Œ/å¹¶è¡Œï¼Œæ”¯æŒä¼˜å…ˆçº§   |
| memory.js          | æ¯ä¸ª agent å†…éƒ¨è®°å¿†ï¼Œæ”¯æŒçŸ­æœŸ/é•¿æœŸè®°å¿†    |
| plugins.js         | æ’ä»¶ç³»ç»Ÿï¼Œå¯æ³¨å†Œå¤–éƒ¨å·¥å…·ã€æœç´¢ã€è®¡ç®—ã€API |
| knowledgeBase.js   | å‘é‡æ•°æ®åº“æ”¯æŒï¼ŒRAG æ£€ç´¢å¢å¼º              |
| llm.js + stream.js | ç»Ÿä¸€å¤§æ¨¡å‹è°ƒç”¨ + æµå¼è¾“å‡º                 |

---

# ğŸ”§ 10ï¸âƒ£ ä¸‹ä¸€æ­¥å¯æ‰©å±•

1. Web UI å¯è§†åŒ–å¤šæ™ºèƒ½ä½“å·¥ä½œæµ
2. Agent è®°å¿†æŒä¹…åŒ–åˆ°æ•°æ®åº“
3. å¹¶è¡Œ Agent + äº‹ä»¶æ€»çº¿è°ƒåº¦
4. RAG + Plugin è‡ªåŠ¨è°ƒç”¨ç­–ç•¥ï¼ˆç±»ä¼¼ AutoGPT / LangGraphï¼‰
5. å¢åŠ æ—¥å¿—å’Œç›‘æ§ç³»ç»Ÿ

---

æˆ‘å¯ä»¥å¸®ä½  **ç”Ÿæˆå®Œæ•´é¡¹ç›® ZIP åŒ…ï¼ŒåŒ…å«æµå¼è¾“å‡º + å†…å­˜ + æ’ä»¶ + çŸ¥è¯†åº“ + Scheduler å¯ç›´æ¥è¿è¡Œ**ï¼Œå¹¶å¸¦ **VSCode è°ƒè¯•é…ç½®**ã€‚

ä½ å¸Œæœ›æˆ‘å¸®ä½ ç”Ÿæˆè¿™ä¸ªå®Œæ•´å·¥ç¨‹å—ï¼Ÿ
